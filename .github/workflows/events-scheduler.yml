name: Events Scheduler

# Note: Scheduled workflows run in UTC timezone and only on the default branch.
# - Weekly: 00:05 UTC (typically 01:05 CET in winter, 02:05 CEST in summer)
# - Monthly: 00:10 UTC on the 1st of each month
# - Email dispatch: Every 15 minutes
# Scheduled workflows may be automatically disabled after 60 days of inactivity in public repos.
on:
  schedule:
    - cron: "5 0 * * 1" # Weekly: Monday 00:05 UTC
    - cron: "10 0 1 * *" # Monthly: 1st of month 00:10 UTC
    - cron: "*/15 * * * *" # Email dispatch: Every 15 minutes
  workflow_dispatch:
    inputs:
      runWeekly:
        type: boolean
        description: "Force weekly events"
        required: false
        default: false
      runMonthly:
        type: boolean
        description: "Force monthly events"
        required: false
        default: false
      runEmailDispatch:
        type: boolean
        description: "Force email dispatch"
        required: false
        default: false

jobs:
  setup-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
      matrix_empty: ${{ steps.generate-matrix.outputs.matrix_empty }}
      secrets_ok: ${{ steps.check-secrets.outputs.secrets_ok }}
    steps:
      - name: Generate matrix
        id: generate-matrix
        shell: bash
        run: |
          # Define shared schedule variables
          WEEKLY_SCHEDULE="5 0 * * 1"
          MONTHLY_SCHEDULE="10 0 1 * *"
          EMAIL_SCHEDULE="*/15 * * * *"

          matrix_entries=()
          matrix_reason=""

          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # For workflow_dispatch: include only entries whose input is true
            # Boolean inputs are converted to "true"/"false" strings by GitHub Actions
            if [ "${{ inputs.runWeekly }}" = "true" ]; then
              matrix_entries+=("{\"name\":\"Trigger weekly events\",\"path\":\"/api/events/weekly\",\"schedule\":\"${WEEKLY_SCHEDULE}\"}")
            fi
            if [ "${{ inputs.runMonthly }}" = "true" ]; then
              matrix_entries+=("{\"name\":\"Trigger monthly events\",\"path\":\"/api/events/monthly\",\"schedule\":\"${MONTHLY_SCHEDULE}\"}")
            fi
            if [ "${{ inputs.runEmailDispatch }}" = "true" ]; then
              matrix_entries+=("{\"name\":\"Dispatch emails\",\"path\":\"/api/events/emails/dispatch\",\"schedule\":\"${EMAIL_SCHEDULE}\"}")
            fi
          elif [ "${{ github.event_name }}" = "schedule" ]; then
            # For schedule: github.event.schedule contains the cron string that triggered this run
            # Use exact string comparison (not glob patterns) to avoid wildcard matching issues
            if [ -n "${{ github.event.schedule }}" ]; then
              current_schedule="${{ github.event.schedule }}"
              if [ "$current_schedule" = "$WEEKLY_SCHEDULE" ]; then
                matrix_entries+=("{\"name\":\"Trigger weekly events\",\"path\":\"/api/events/weekly\",\"schedule\":\"${WEEKLY_SCHEDULE}\"}")
              elif [ "$current_schedule" = "$MONTHLY_SCHEDULE" ]; then
                matrix_entries+=("{\"name\":\"Trigger monthly events\",\"path\":\"/api/events/monthly\",\"schedule\":\"${MONTHLY_SCHEDULE}\"}")
              elif [ "$current_schedule" = "$EMAIL_SCHEDULE" ]; then
                matrix_entries+=("{\"name\":\"Dispatch emails\",\"path\":\"/api/events/emails/dispatch\",\"schedule\":\"${EMAIL_SCHEDULE}\"}")
              else
                echo "::error::Unknown schedule: $current_schedule"
                matrix_reason="unknown_schedule"
              fi
            else
              echo "::error::github.event.schedule not present for scheduled workflow"
              matrix_reason="missing_schedule"
            fi
          fi

          # Build matrix JSON (compact output to avoid multiline issues in $GITHUB_OUTPUT)
          if [ ${#matrix_entries[@]} -eq 0 ]; then
            if [ -n "$matrix_reason" ]; then
              echo "::warning::No matching endpoints for schedule; skipping"
            else
              echo "No matching endpoints found"
            fi
            matrix_json='{"include":[]}'
            matrix_empty="true"
          else
            matrix_json='{"include":['
            for i in "${!matrix_entries[@]}"; do
              if [ "$i" -gt 0 ]; then
                matrix_json+=","
              fi
              matrix_json+="${matrix_entries[$i]}"
            done
            matrix_json+="]}"
            matrix_empty="false"
          fi

          echo "matrix=$matrix_json" >> "$GITHUB_OUTPUT"
          echo "matrix_empty=$matrix_empty" >> "$GITHUB_OUTPUT"
          echo "Generated matrix: $matrix_json"
          echo "Matrix empty: $matrix_empty"

      - name: Check required secrets/variables
        id: check-secrets
        shell: bash
        run: |
          if [ -z "${{ secrets['EVENTS_CRON_SECRET'] }}" ] || [ -z "${{ secrets['FRONTEND_URL'] || vars.FRONTEND_URL || '' }}" ]; then
            echo "secrets_ok=false" >> "$GITHUB_OUTPUT"
            echo "::warning::trigger-events job will be skipped because required config is missing."
            echo "Required: EVENTS_CRON_SECRET (secret) and FRONTEND_URL (secret or variable)."
          else
            echo "secrets_ok=true" >> "$GITHUB_OUTPUT"
          fi

  trigger-events:
    needs: setup-matrix
    # Run only when we have work (matrix not empty) AND required secrets are present.
    if: ${{ needs.setup-matrix.outputs.matrix_empty == 'false' && needs.setup-matrix.outputs.secrets_ok == 'true' }}
    # Concurrency control: prevent overlapping runs for the same endpoint
    # This is especially important for the frequent email dispatch job (every 15 minutes)
    concurrency:
      group: events-scheduler-${{ matrix.path }}
      cancel-in-progress: false
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.setup-matrix.outputs.matrix) }}
      # CURL_OPTS wird dynamisch im "Validate base URL" Step gesetzt, basierend auf curl-Version
    steps:
      - name: Set environment variables
        shell: bash
        run: |
          # Set EVENTS_BASE_URL from FRONTEND_URL (secret or repository variable)
          # The API endpoints are under /api/events, so we use the base URL
          FRONTEND_URL="${{ secrets['FRONTEND_URL'] || vars.FRONTEND_URL || '' }}"
          if [ -n "${FRONTEND_URL}" ]; then
            # Remove trailing slash if present
            FRONTEND_URL="${FRONTEND_URL%/}"
            # Ensure it starts with http:// or https://
            if [[ ! "${FRONTEND_URL}" =~ ^https?:// ]]; then
              FRONTEND_URL="https://${FRONTEND_URL}"
            fi
            echo "EVENTS_BASE_URL=${FRONTEND_URL}" >> "$GITHUB_ENV"
          else
            echo "EVENTS_BASE_URL=" >> "$GITHUB_ENV"
          fi

          # Set EVENTS_CRON_SECRET from secrets
          echo "EVENTS_CRON_SECRET=${{ secrets['EVENTS_CRON_SECRET'] }}" >> "$GITHUB_ENV"

      - name: Validate base URL
        shell: bash
        run: |
          if [ -z "${EVENTS_BASE_URL}" ]; then
            echo "::error::Set EVENTS_BASE_URL secret to your deployed host (e.g. https://vertic-id.com)." >&2
            exit 1
          fi
          if [ -z "${EVENTS_CRON_SECRET}" ]; then
            echo "::error::Set EVENTS_CRON_SECRET secret." >&2
            exit 1
          fi
          # Debug: Check if secret is set (without revealing value)
          if [ -n "${EVENTS_CRON_SECRET}" ]; then
            secret_length=${#EVENTS_CRON_SECRET}
            echo "EVENTS_CRON_SECRET is set (length: ${secret_length} characters)"
          fi
          # Ensure URL starts with http:// or https://
          if [[ ! "${EVENTS_BASE_URL}" =~ ^https?:// ]]; then
            echo "::warning::URL does not start with http:// or https://, prepending https://"
            EVENTS_BASE_URL="https://${EVENTS_BASE_URL}"
            echo "Using URL: ${EVENTS_BASE_URL}"
          fi
          # Remove trailing slash
          EVENTS_BASE_URL="${EVENTS_BASE_URL%/}"
          echo "EVENTS_BASE_URL=${EVENTS_BASE_URL}" >> "$GITHUB_ENV"

          # Check curl version and set CURL_OPTS accordingly (once, to avoid repeated warnings)
          # --fail-with-body requires curl 7.76.0+, otherwise use --fail
          if curl --help 2>/dev/null | grep -q "fail-with-body"; then
            CURL_OPTS="--fail-with-body --show-error --ipv4 --connect-timeout 15 --max-time 60 --retry 3 --retry-delay 10 --retry-max-time 45 --tlsv1.2 --tls-max 1.3 --location --post301 --post302 --post303"
          else
            CURL_OPTS="--fail --show-error --ipv4 --connect-timeout 15 --max-time 60 --retry 3 --retry-delay 10 --retry-max-time 45 --tlsv1.2 --tls-max 1.3 --location --post301 --post302 --post303"
          fi
          echo "CURL_OPTS=${CURL_OPTS}" >> "$GITHUB_ENV"

      - name: ${{ matrix.name }}
        shell: bash
        run: |
          echo "Calling ${EVENTS_BASE_URL}${{ matrix.path }}"

          # Debug: Verify secret is set (without revealing value)
          if [ -z "${EVENTS_CRON_SECRET}" ]; then
            echo "::error::EVENTS_CRON_SECRET is not set in environment"
            exit 1
          fi
          secret_length=${#EVENTS_CRON_SECRET}
          echo "EVENTS_CRON_SECRET is set (length: ${secret_length} characters)"

          # CURL_OPTS is already set in the previous step based on curl version
          # No need to check again - this avoids the warning message

          # Use set +e around curl to ensure error handling works correctly with command substitution
          set +e
          response=$(curl ${CURL_OPTS} -X POST \
            -H "Authorization: Bearer ${EVENTS_CRON_SECRET}" \
            -H "Content-Type: application/json" \
            -w "\nHTTP_CODE:%{http_code}\n" \
            "${EVENTS_BASE_URL}${{ matrix.path }}" 2>&1)
          exit_code=$?
          set -e

          # Extract HTTP status code from response
          http_code=$(echo "$response" | grep -o "HTTP_CODE:[0-9]*" | cut -d: -f2 || echo "")

          if [ "$exit_code" -ne 0 ]; then
            echo "::error::curl failed with exit code $exit_code"
            echo "Response: $response"
            # Additional debug info for 401 errors
            if [ "$http_code" = "401" ] || echo "$response" | grep -q "401"; then
              echo "::error::Authentication failed (401). Please verify:"
              echo "  1. EVENTS_CRON_SECRET in GitHub Actions matches EVENTS_CRON_SECRET in Vercel"
              echo "  2. The secret is set in all Vercel environments (Production, Preview, Development)"
              echo "  3. No extra whitespace or newlines in the secret value"
            fi
            exit $exit_code
          fi

          # Check HTTP status code even if curl succeeded
          if [ -n "$http_code" ] && [ "$http_code" -ge 400 ]; then
            echo "::error::API returned HTTP $http_code"
            echo "Response: $response"
            if [ "$http_code" = "401" ]; then
              echo "::error::Authentication failed (401). Please verify:"
              echo "  1. EVENTS_CRON_SECRET in GitHub Actions matches EVENTS_CRON_SECRET in Vercel"
              echo "  2. The secret is set in all Vercel environments (Production, Preview, Development)"
              echo "  3. No extra whitespace or newlines in the secret value"
            fi
            exit 1
          fi

          # Success - remove HTTP_CODE line from output for cleaner logs
          clean_response=$(echo "$response" | grep -v "HTTP_CODE:")
          echo "$clean_response"

          # Parse and log response details
          if echo "$clean_response" | grep -q '"skipped"'; then
            if echo "$clean_response" | grep -q '"reason"'; then
              reason=$(echo "$clean_response" | grep -o '"reason":"[^"]*"' | cut -d'"' -f4)
              echo "::notice::Job was skipped: $reason"
              if [ "$reason" = "already-processed" ]; then
                echo "::info::This week/month was already processed. Use force=true to reprocess."
              fi
            fi
          fi

          # Log job execution details
          if echo "$clean_response" | grep -q '"processedUsers"'; then
            users=$(echo "$clean_response" | grep -o '"processedUsers":[0-9]*' | cut -d: -f2)
            echo "::info::Job processed $users users"
          fi

          if echo "$clean_response" | grep -q '"processed"'; then
            emails=$(echo "$clean_response" | grep -o '"processed":[0-9]*' | cut -d: -f2)
            failed=$(echo "$clean_response" | grep -o '"failed":[0-9]*' | cut -d: -f2 || echo "0")
            echo "::info::Email dispatch: $emails processed, $failed failed"
          fi
