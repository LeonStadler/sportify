name: Events Scheduler

# Note: Scheduled workflows run in UTC timezone and only on the default branch.
# - Weekly: 00:05 UTC (typically 01:05 CET in winter, 02:05 CEST in summer)
# - Monthly: 00:10 UTC on the 1st of each month
# - Email dispatch: Every 15 minutes
# Scheduled workflows may be automatically disabled after 60 days of inactivity in public repos.
on:
  schedule:
    - cron: "5 0 * * 1"    # Weekly: Monday 00:05 UTC
    - cron: "10 0 1 * *"   # Monthly: 1st of month 00:10 UTC
    - cron: "*/15 * * * *" # Email dispatch: Every 15 minutes
  workflow_dispatch:
    inputs:
      runWeekly:
        type: boolean
        description: "Force weekly events"
        required: false
        default: false
      runMonthly:
        type: boolean
        description: "Force monthly events"
        required: false
        default: false
      runEmailDispatch:
        type: boolean
        description: "Force email dispatch"
        required: false
        default: false

jobs:
  setup-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
      matrix_empty: ${{ steps.generate-matrix.outputs.matrix_empty }}
    steps:
      - name: Generate matrix
        id: generate-matrix
        shell: bash
        run: |
          # Define shared schedule variables
          WEEKLY_SCHEDULE="5 0 * * 1"
          MONTHLY_SCHEDULE="10 0 1 * *"
          EMAIL_SCHEDULE="*/15 * * * *"
          
          matrix_entries=()
          matrix_reason=""
          
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # For workflow_dispatch: include only entries whose input is true
            # Boolean inputs are converted to "true"/"false" strings by GitHub Actions
            if [ "${{ inputs.runWeekly }}" = "true" ]; then
              matrix_entries+=("{\"name\":\"Trigger weekly events\",\"path\":\"/api/events/weekly\",\"schedule\":\"${WEEKLY_SCHEDULE}\"}")
            fi
            if [ "${{ inputs.runMonthly }}" = "true" ]; then
              matrix_entries+=("{\"name\":\"Trigger monthly events\",\"path\":\"/api/events/monthly\",\"schedule\":\"${MONTHLY_SCHEDULE}\"}")
            fi
            if [ "${{ inputs.runEmailDispatch }}" = "true" ]; then
              matrix_entries+=("{\"name\":\"Dispatch emails\",\"path\":\"/api/events/emails/dispatch\",\"schedule\":\"${EMAIL_SCHEDULE}\"}")
            fi
          elif [ "${{ github.event_name }}" = "schedule" ]; then
            # For schedule: github.event.schedule contains the cron string that triggered this run
            # Use exact string comparison (not glob patterns) to avoid wildcard matching issues
            if [ -n "${{ github.event.schedule }}" ]; then
              current_schedule="${{ github.event.schedule }}"
              if [ "$current_schedule" = "$WEEKLY_SCHEDULE" ]; then
                matrix_entries+=("{\"name\":\"Trigger weekly events\",\"path\":\"/api/events/weekly\",\"schedule\":\"${WEEKLY_SCHEDULE}\"}")
              elif [ "$current_schedule" = "$MONTHLY_SCHEDULE" ]; then
                matrix_entries+=("{\"name\":\"Trigger monthly events\",\"path\":\"/api/events/monthly\",\"schedule\":\"${MONTHLY_SCHEDULE}\"}")
              elif [ "$current_schedule" = "$EMAIL_SCHEDULE" ]; then
                matrix_entries+=("{\"name\":\"Dispatch emails\",\"path\":\"/api/events/emails/dispatch\",\"schedule\":\"${EMAIL_SCHEDULE}\"}")
              else
                echo "::error::Unknown schedule: $current_schedule"
                matrix_reason="unknown_schedule"
              fi
            else
              echo "::error::github.event.schedule not present for scheduled workflow"
              matrix_reason="missing_schedule"
            fi
          fi
          
          # Build matrix JSON (compact output to avoid multiline issues in $GITHUB_OUTPUT)
          if [ ${#matrix_entries[@]} -eq 0 ]; then
            if [ -n "$matrix_reason" ]; then
              echo "::warning::No matching endpoints for schedule; skipping"
            else
              echo "No matching endpoints found"
            fi
            matrix_json='{"include":[]}'
            matrix_empty="true"
          else
            matrix_json='{"include":['
            for i in "${!matrix_entries[@]}"; do
              if [ "$i" -gt 0 ]; then
                matrix_json+=","
              fi
              matrix_json+="${matrix_entries[$i]}"
            done
            matrix_json+="]}"
            matrix_empty="false"
          fi
          
          echo "matrix=$matrix_json" >> "$GITHUB_OUTPUT"
          echo "matrix_empty=$matrix_empty" >> "$GITHUB_OUTPUT"
          echo "Generated matrix: $matrix_json"
          echo "Matrix empty: $matrix_empty"

  trigger-events:
    needs: setup-matrix
    if: ${{ needs.setup-matrix.outputs.matrix_empty == 'false' }}
    # Concurrency control: prevent overlapping runs for the same endpoint
    # This is especially important for the frequent email dispatch job (every 15 minutes)
    concurrency:
      group: events-scheduler-${{ matrix.path }}
      cancel-in-progress: false
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.setup-matrix.outputs.matrix) }}
    env:
      # Retry policy: retries on transient errors (network, DNS, SSL, timeouts) but not on HTTP errors (401/403/404/500)
      # --retry 3: up to 3 retries on transient failures
      # --retry-delay 10: wait 10 seconds between retries
      # --retry-max-time 45: total time limit for all retries (prevents infinite retry loops)
      # --fail-with-body: treat HTTP errors (4xx/5xx) as failures but include response body in error output (requires curl 7.76.0+)
      # Falls --fail-with-body nicht verfügbar ist, wird --fail verwendet (Response-Body wird dann unterdrückt)
      CURL_OPTS: "--fail-with-body --show-error --ipv4 --connect-timeout 15 --max-time 60 --retry 3 --retry-delay 10 --retry-max-time 45 --tlsv1.2 --tls-max 1.3 --location --post301 --post302 --post303"
    steps:
      - name: Set environment variables
        shell: bash
        run: |
          # Set EVENTS_BASE_URL from secrets (fallback to FRONTEND_URL)
          if [ -n "${{ secrets.EVENTS_BASE_URL }}" ]; then
            echo "EVENTS_BASE_URL=${{ secrets.EVENTS_BASE_URL }}" >> "$GITHUB_ENV"
          elif [ -n "${{ secrets.FRONTEND_URL }}" ]; then
            echo "EVENTS_BASE_URL=${{ secrets.FRONTEND_URL }}" >> "$GITHUB_ENV"
          fi
          
          # Set EVENTS_CRON_SECRET from secrets
          if [ -n "${{ secrets.EVENTS_CRON_SECRET }}" ]; then
            echo "EVENTS_CRON_SECRET=${{ secrets.EVENTS_CRON_SECRET }}" >> "$GITHUB_ENV"
          fi
      
      - name: Validate base URL
        shell: bash
        run: |
          if [ -z "${EVENTS_BASE_URL}" ]; then
            echo "::error::Set either EVENTS_BASE_URL or FRONTEND_URL secret to your deployed host (e.g. https://vertic-id.com)." >&2
            exit 1
          fi
          if [ -z "${EVENTS_CRON_SECRET}" ]; then
            echo "::error::Set EVENTS_CRON_SECRET secret." >&2
            exit 1
          fi
          # Ensure URL starts with http:// or https://
          if [[ ! "${EVENTS_BASE_URL}" =~ ^https?:// ]]; then
            echo "::warning::URL does not start with http:// or https://, prepending https://"
            EVENTS_BASE_URL="https://${EVENTS_BASE_URL}"
            echo "Using URL: ${EVENTS_BASE_URL}"
          fi
          # Remove trailing slash
          EVENTS_BASE_URL="${EVENTS_BASE_URL%/}"
          echo "EVENTS_BASE_URL=${EVENTS_BASE_URL}" >> "$GITHUB_ENV"

      - name: ${{ matrix.name }}
        shell: bash
        run: |
          echo "Calling ${EVENTS_BASE_URL}${{ matrix.path }}"
          # Check if --fail-with-body is supported (requires curl 7.76.0+)
          # If not, fall back to --fail (response body will be suppressed on HTTP errors)
          if curl --help | grep -q "fail-with-body"; then
            curl_opts="${CURL_OPTS}"
          else
            echo "::warning::curl version does not support --fail-with-body, using --fail instead"
            curl_opts="${CURL_OPTS/--fail-with-body/--fail}"
          fi
          
          # Use set +e around curl to ensure error handling works correctly with command substitution
          set +e
          response=$(curl ${curl_opts} -X POST \
            -H "Authorization: Bearer ${EVENTS_CRON_SECRET}" \
            -w "\nHTTP_CODE:%{http_code}\n" \
            "${EVENTS_BASE_URL}${{ matrix.path }}" 2>&1)
          exit_code=$?
          set -e
          if [ "$exit_code" -ne 0 ]; then
            echo "::error::curl failed with exit code $exit_code"
            echo "Response: $response"
            exit $exit_code
          fi
          echo "$response"
